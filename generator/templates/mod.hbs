// @generated
// by cdevents/sdk-rust/generator (mod.hbs)

use serde::de::Error;

{{#each variants }}
pub mod {{this.rust_module}};
{{/each}}

use serde::{Serialize, Deserialize};

{{#each variants }}
pub const {{to_screaming_snake_case this.rust_module}}: &str = "{{ this.context_type }}";
{{/each}}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(untagged)] // TODO how to use content of context.type as discriminator ?
pub enum Content {
    {{#each variants }}
    {{to_class_case this.rust_module}}({{this.rust_module}}::Content),
    {{/each}}
}

impl Content {
    pub fn from_json(ty: &str, json: serde_json::Value) -> Result<Self, serde_json::Error>{
        match ty {
            {{#each variants }}
            {{to_screaming_snake_case this.rust_module}} => {
                let variant: {{this.rust_module}}::Content = serde_json::from_value(json)?;
                Ok(variant.into())
            },
            {{/each}}
            variant => Err(serde_json::Error::custom(format_args!(
                "unknown variant `{}`, expected 'dev.cdevents.\{{subject}}.\{{predicate}}.\{{version}}'",
                variant,
            ))),
        }
    }

    pub fn ty(&self) -> &'static str {
        match self {
            {{#each variants }}
            Self::{{to_class_case this.rust_module}}(_) => {{to_screaming_snake_case this.rust_module}},
            {{/each}}
        }
    }

    pub fn subject_predicate(&self) -> (&'static str, &'static str){
        let mut split = self.ty().split('.');
        (
            split.nth(2).expect("fargment 2 of ty should always exists"),
            split.nth(3).expect("fargment 3 of ty should always exists")
        )
    }

}

{{#each variants }}
impl From<{{this.rust_module}}::Content> for Content {
    fn from(value: {{this.rust_module}}::Content) -> Self {
        Self::{{to_class_case this.rust_module}}(value)
    }
}
{{/each}}

#[cfg(feature = "testkit")]
impl<> proptest::arbitrary::Arbitrary for Content {
    type Parameters = ();
    type Strategy = proptest::strategy::BoxedStrategy<Self>;

    fn arbitrary_with(_args: Self::Parameters) -> Self::Strategy {
        use proptest::prelude::*;
        prop_oneof![
{{#each variants }}
            any::<{{this.rust_module}}::Content>().prop_map(Content::from),
{{/each}}
        ].boxed()
    }
}
